//
// CPU instruction declaration
//


0000.nnnn.mmmm.0111     mul.l       "i32 (Rn x Rm) -> MACL"
0000.0000.0000.1001     nop         "No operation"
0000.0000.0000.1000     clrt        "0 -> T"
0000.0000.0001.1000     sett        "1 -> T"
0000.0000.0001.1001     div0u       "0 -> M/Q/T"
0000.0000.0010.1000     clrmac      "0 -> MACH,MACL"
0000.nnnn.0010.1001     movt        "T -> Rn"
0000.0000.0100.1000     clrs        "0 -> S"
0000.0000.0101.1000     sets        "1 -> S"


0010.nnnn.mmmm.0111     div0s       "<Rn>MSB -> Q, <Rm>MSB -> M, M^Q -> T"
0010.nnnn.mmmm.1000     tst         "((Rn & Rm) == 0) -> T"
0010.nnnn.mmmm.1001     and         "(Rn & Rm) -> Rn"
0010.nnnn.mmmm.1010     xor         "(Rn ^ Rm) -> Rn"
0010.nnnn.mmmm.1011     or          "(Rn | Rm) -> Rn"
0010.nnnn.mmmm.1100     cmp/str     "any bytes are equal -> T"
0010.nnnn.mmmm.1101     xtrct       "Rm:Rn middle 32 bits → Rn"
0010.nnnn.mmmm.1110     muls.w      "i16 (Rn x Rm) -> MACL"
0010.nnnn.mmmm.1111     mulu.w      "u16 (Rn x Rm) -> MACL"


0011.nnnn.mmmm.0000     cmp/eq      "(Rn == Rm) -> T"
0011.nnnn.mmmm.0010     cmp/hs      "(unsigned)(Rn >= Rm) -> T"
0011.nnnn.mmmm.0011     cmp/ge      "(signed)(Rn >= Rm) -> T"
0011.nnnn.mmmm.0100     div1        "1-step division (Rn/Rm)->Rn"
0011.nnnn.mmmm.0101     dmulu.l     "u64 (Rn x Rm) -> MACH,MACL"
0011.nnnn.mmmm.0110     cmp/hi      "(unsigned)(Rn > Rm) -> T"
0011.nnnn.mmmm.0111     cmp/gt      "(signed)(Rn > Rm) -> T"
0011.nnnn.mmmm.1000     sub         "(Rn - Rm) -> Rn"
0011.nnnn.mmmm.1010     subc        "(Rn - Rm - T) -> Rn, borrow -> T"
0011.nnnn.mmmm.1011     subv        "(Rn - Rm) -> Rn, underflow -> T"
0011.nnnn.mmmm.1100     add         "(Rn + Rm) -> Rn"
0011.nnnn.mmmm.1101     dmuls.l     "i64 (Rn x Rm) -> MACH,MACHL"
0011.nnnn.mmmm.1110     addc        "(Rn + Rm + T) -> Rn, carry → T"
0011.nnnn.mmmm.1111     addv        "(Rn + Rm) -> Rn, overflow → T"


0100.nnnn.0000.0000     shll        "T <- Rn <- 0"
0100.nnnn.0000.0001     shlr        "0 -> Rn -> T"
0100.nnnn.0000.0100     rotl        "T <- Rn <- MSB"
0100.nnnn.0000.0101     rotr        "LSB -> Rn -> T"
0100.nnnn.0000.1000     shll2       "(Rn << 2) -> Rn"
0100.nnnn.0000.1001     shlr2       "(Rn >> 2) -> Rn"
0100.nnnn.0001.0000     dt          "(Rn – 1) -> Rn && (Rn == 0) -> T"
0100.nnnn.0001.0001     cmp/pz      "(signed)(Rn >= 0) -> T"
0100.nnnn.0001.0101     cmp/pl      "(signed)(Rn > 0) -> T"
0100.nnnn.0001.1000     shll8       "(Rn << 8) -> Rn"
0100.nnnn.0001.1001     shlr8       "(Rn >> 8) -> Rn"
0100.nnnn.0010.0100     rotcl       "T <- Rn <- T"
0100.nnnn.0010.0101     rotcr       "T -> Rn -> T"
0100.nnnn.0010.0000     shal        "T <- Rn <- 0"
0100.nnnn.0010.0001     shar        "MSB -> Rn -> T"
0100.nnnn.0010.1000     shll16      "(Rn << 16) -> Rn"
0100.nnnn.0010.1001     shlr16      "(Rn >> 16) -> Rn"
0100.nnnn.mmmm.1100     shad        "(Rn << Rm) -> Rn, MSB -> Rn"
0100.nnnn.mmmm.1101     shld        "(Rn << Rm) -> Rn, 0 -> Rn"


0110.nnnn.mmmm.0011     mov         "Rm -> Rn"
0110.nnnn.mmmm.0111     not         "(~Rm) -> Rn"
0110.nnnn.mmmm.1000     swap.b      "Rm -> swap lower 2 bytes -> Rn"
0110.nnnn.mmmm.1001     swap.w      "Rm -> swap upper/lower words -> Rn"
0110.nnnn.mmmm.1010     negc        "(0 - Rm - T) -> Rn, borrow -> T"
0110.nnnn.mmmm.1011     neg         "(0 - Rm) -> Rn"
0110.nnnn.mmmm.1100     extu.b      "Rm zero-extended from byte -> Rn"
0110.nnnn.mmmm.1101     extu.w      "Rm zero-extended from word -> Rn"
0110.nnnn.mmmm.1110     exts.b      "Rm sign-extended from byte -> Rn"
0110.nnnn.mmmm.1111     exts.w      "Rm sign-extended from word -> Rn"
